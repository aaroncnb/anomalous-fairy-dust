
# coding: utf-8

# In[2]:

get_ipython().magic(u'matplotlib inline')
#from IPython.external import mathjax; mathjax.install_mathjax()
import matplotlib
import numpy as np
import matplotlib.pyplot as plt
import healpy as hp
import healpy.projector as pro
import pyfits
import pidly
idl = pidly.IDL()


# In[ ]:




# In[3]:

##This file just contains the "setup" for the circular aperture photometry, 
## to be carrie outon HEALPix maps-
## it just definsed the settings and runs the MEP code (test run)
##First, just define the needed variables/settings as you would in IDL (since the syntax is the same), 
##but now you're doing it with the Python terminal
inputlist = 'inputlist_mep_test.list'
maplist  =  'maplist_mep_test.list'
radius = 60.0
rinner = 1.5
router = 2.0
##The following is the general syntax for running and IDL command from Python.. Inside the (), you keep the IDL syntax
#idl('multiepoch_photometry_akari, inputlist, maplist=maplist, radius=radius, rinner=rinner, router=router, /galactic')
##Use the following if you're running a 'named' function...
#idl.multiepoch_photometry_akari(inputlist, maplist=maplist, radius=radius, rinner=rinner, router=router, galactic=True)
##Use the following if you're working with a PROcedure, but not necessarily a named function
idl.pro('multiepoch_photometry_akari',inputlist, maplist=maplist, radius=radius, rinner=rinner, router=router, galactic=True)


# In[4]:

###Now let's play with retrieving values:
#Since the actual photometry is run "within" a the PRO 'multiepoch...pro', 
#we'll have to restore the .SAV file generated by that routine.
#Well, me may not *have* to do it that way, I just haven't yet learned a better way..

idl.pro('restore','multiepoch_photometry_akari_.sav')

###Ok, the actual value-retrieving test...
## This is done with Python.. well, of course it is, that's the point of using pidly!
## You just print a variable like you would any other time, except that you prefix it with 'idl.'


#print idl.ev('fd_all')
fd_all = idl.ev('fd_all')
#print fd_all
#print idl.ev('fd_err_all')
fd_err_all = idl.ev('fd_err_all')
#print fd_err_all


# In[6]:

##We'll be making multiple plots in this one box, so first we set that up:
#Set the "figure number" -
#plt.figure(1)

##Then for each plot, we change the sub'plot number: We'll plot IRC 9 micron vs. AME first...
#plt.subplot(151)
#print fd_all[0]
plt.plot(fd_all[0],fd_all[1],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME')
plt.ylabel('AKARI 9 Micron')
plt.title('Comparison of AME with IR Bands: 9 micron')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[1])
print R

###Now the second plot: AME vs 65
#plt.subplot(152)
plt.plot(fd_all[0],fd_all[2],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('AKARI 65 Micron Flux Density')
plt.title('Comparison of AME with IR Bands: 65 micron')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[2])
print R

### AME vs 90
#plt.subplot(153)
plt.plot(fd_all[0],fd_all[3],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('AKARI 90 Micron Flux Density')
plt.title('Comparison of AME with IR Bands: 90 micron')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[3])
print R

### AME vs 140
#plt.subplot(154)
plt.plot(fd_all[0],fd_all[4],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('AKARI 140 Micron Flux Density')
plt.title('Comparison of AME with IR Bands: 140 micron')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[4])
print R

### AME vs 160
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[5],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('AKARI 160 Micron Flux Density')
plt.title('Comparison of AME with IR Bands: 160 micron')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[5])
print R

### AME vs 857
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[6],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('PLANCK 857 Micron Flux Density')
plt.title('Comparison of AME with IR Bands: 857 GHz')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[6])
print R

### AME vs 545
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[7],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('PLANCK 545 Micron Flux Density')
plt.title('Comparison of AME with IR Bands: 545 GHz')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[7])
print R

### AME vs 353
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[8],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('PLANCK 353 GHz Flux Density')
plt.title('Comparison of AME with IR Bands: 353 GHz')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[8])
print R

### AME vs 217
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[9],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('PLANCK 217 GHz Flux Density')
plt.title('Comparison of AME with IR Bands: 217 GHz')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[9])
print R

### AME vs 143
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[10],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('PLANCK 143 GHz Flux Density')
plt.title('Comparison of AME with IR Bands: 143 GHz')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[10])
print R

### AME vs 100
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[11],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('PLANCK 100 GHz Flux Density')
plt.title('Comparison of AME with IR Bands: 100 GHz')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[11])
print R


# In[ ]:

##############################################
#############Blackbody fitting?###############
##############################################

##Since we want to get away from IDL as much as possible,
###let' at least put the simple steps of the color-correctin
###into python (rather than relpying ont the DustEM IDL wrapper)

####Make a dictionary to hold the map frequencies and names:
#####'BandName':FREQ

