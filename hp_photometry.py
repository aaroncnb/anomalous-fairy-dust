
# coding: utf-8

# In[2]:

get_ipython().magic(u'matplotlib inline')
#from IPython.external import mathjax; mathjax.install_mathjax()
import matplotlib
import numpy as np
import matplotlib.pyplot as plt
import healpy as hp
import healpy.projector as pro
import pyfits
import pidly
idl = pidly.IDL()


# In[ ]:




# In[3]:

##This file just contains the "setup" for the circular aperture photometry, 
## to be carrie outon HEALPix maps-
## it just definsed the settings and runs the MEP code (test run)
##First, just define the needed variables/settings as you would in IDL (since the syntax is the same), 
##but now you're doing it with the Python terminal
inputlist = 'inputlist_mep_test.list'
maplist  =  'maplist_mep_test.list'
radius = 60.0
rinner = 1.5
router = 2.0
##The following is the general syntax for running and IDL command from Python.. Inside the (), you keep the IDL syntax
#idl('multiepoch_photometry_akari, inputlist, maplist=maplist, radius=radius, rinner=rinner, router=router, /galactic')
##Use the following if you're running a 'named' function...
#idl.multiepoch_photometry_akari(inputlist, maplist=maplist, radius=radius, rinner=rinner, router=router, galactic=True)
##Use the following if you're working with a PROcedure, but not necessarily a named function
idl.pro('multiepoch_photometry_akari',inputlist, maplist=maplist, radius=radius, rinner=rinner, router=router, galactic=True)


# In[4]:

###Now let's play with retrieving values:
#Since the actual photometry is run "within" a the PRO 'multiepoch...pro', 
#we'll have to restore the .SAV file generated by that routine.
#Well, me may not *have* to do it that way, I just haven't yet learned a better way..

idl.pro('restore','multiepoch_photometry_akari_.sav')

###Ok, the actual value-retrieving test...
## This is done with Python.. well, of course it is, that's the point of using pidly!
## You just print a variable like you would any other time, except that you prefix it with 'idl.'


#print idl.ev('fd_all')
fd_all = idl.ev('fd_all')
#print fd_all
#print idl.ev('fd_err_all')
fd_err_all = idl.ev('fd_err_all')
#print fd_err_all


# In[6]:

##We'll be making multiple plots in this one box, so first we set that up:
#Set the "figure number" -
#plt.figure(1)

##Then for each plot, we change the sub'plot number: We'll plot IRC 9 micron vs. AME first...
#plt.subplot(151)
#print fd_all[0]
plt.plot(fd_all[0],fd_all[1],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME')
plt.ylabel('AKARI 9 Micron')
plt.title('Comparison of AME with IR Bands: 9 micron')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[1])
print R

###Now the second plot: AME vs 65
#plt.subplot(152)
plt.plot(fd_all[0],fd_all[2],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('AKARI 65 Micron Flux Density')
plt.title('Comparison of AME with IR Bands: 65 micron')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[2])
print R

### AME vs 90
#plt.subplot(153)
plt.plot(fd_all[0],fd_all[3],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('AKARI 90 Micron Flux Density')
plt.title('Comparison of AME with IR Bands: 90 micron')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[3])
print R

### AME vs 140
#plt.subplot(154)
plt.plot(fd_all[0],fd_all[4],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('AKARI 140 Micron Flux Density')
plt.title('Comparison of AME with IR Bands: 140 micron')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[4])
print R

### AME vs 160
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[5],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('AKARI 160 Micron Flux Density')
plt.title('Comparison of AME with IR Bands: 160 micron')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[5])
print R

### AME vs 857
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[6],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('PLANCK 857 Micron Flux Density')
plt.title('Comparison of AME with IR Bands: 857 GHz')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[6])
print R

### AME vs 545
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[7],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('PLANCK 545 Micron Flux Density')
plt.title('Comparison of AME with IR Bands: 545 GHz')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[7])
print R

### AME vs 353
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[8],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('PLANCK 353 GHz Flux Density')
plt.title('Comparison of AME with IR Bands: 353 GHz')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[8])
print R

### AME vs 217
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[9],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('PLANCK 217 GHz Flux Density')
plt.title('Comparison of AME with IR Bands: 217 GHz')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[9])
print R

### AME vs 143
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[10],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('PLANCK 143 GHz Flux Density')
plt.title('Comparison of AME with IR Bands: 143 GHz')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[10])
print R

### AME vs 100
#plt.subplot(155)
plt.plot(fd_all[0],fd_all[11],'ro')
#Set the axes scaling, i.e. linear or log
plt.yscale('log')
plt.xscale('log')
#Throw some text on those axes...
plt.xlabel('AME Flux Density')
plt.ylabel('PLANCK 100 GHz Flux Density')
plt.title('Comparison of AME with IR Bands: 100 GHz')
plt.grid(True)
plt.show()
R = np.corrcoef(fd_all[0],fd_all[11])
print R


# In[ ]:

##############################################
#############Blackbody fitting?###############
##############################################

##Since we want to get away from IDL as much as possible,
###let' at least put the simple steps of the color-correctin
###into python (rather than relpying ont the DustEM IDL wrapper)

####Make a dictionary to hold the map frequencies and names:
#####'BandName':FREQ

filters = {
	'LFI1':[30,'filter_lfi30.txt']
	'LFI2':[44,filter_lfi44.txt']
	'LFI3':[70,filter_lfi70.txt']
	'LFI4':[100,filter_lfi100.txt']
	'HFI1':[143,filter_hfi143.txt']
	'HFI2':[217,filter_hfi217.txt']
	'HFI3':[353,filter_hfi353.txt']
	'HFI4':[545,filter_hfi545.txt']
	'HFI5':[857,filter_hfi857.txt']
	'AKARI6':[1874,filter_N160.txt']
	'AKARI5':[2141,filter_WL.txt']
	'IRAS4':[2998,filter_iras100.txt']
	'AKARI4'[3331',filter_WS.txt']
	'AKARI3':[4612,filter_N60.txt']
	'IRAS3':[4997',filter_iras60.txt']
	'IRAS2':[11992,
	'AKARI2':[16655,
	'IRAS1':[24983,
	'AKARI1':[33310}
	
cc=dblarr(Nbands)



FOR i=0L,Nbands-1 DO BEGIN
  st=(*!dustem_filters).(iinstru)
  ii=(where(st.filter_names EQ filter_names(i)))(0)
  CASE strupcase(fluxconvs(i)) OF
    'NUINU=CSTE': BEGIN
      spec_int=interpol(spec2,wavein2,*(st.use_wavelengths(ii)))
      num=integral(*(st.us_ewavelengths(ii)),spec_int*(*(st.use_transmissions(ii)))/(*(st.use_wa$
      den=integral(*(st.use_wavelengths(ii)),(*(st.use_transmissions(ii)))/(*(st.use_wavelengths$
      spec0=interpol(spec2,wavein2,st.central_wavelengths(ii))
      cc(i)=num/den/spec0*(st.central_wavelengths(ii))
      sed(i)=spec0*cc(i)
    END
                                                                              
                                                                              
##Run CC Function
                                                                              
                                                                              
                                                                                    (";b.b Calculate color correction factors based on results of the first fitting")

      Nfine    = 500
      wfine    = RAMP(Nfine,1.,1000,/POW) ;; Create a logarithmic ramp (private function)
      nufine = get_ipython().getoutput(u'MKS.clight/!MKS.micron/wfine')

      
      sed_cc("= dustem_cc (wfine, nufine*MODBB(wfine,EXP(parm[1]),parm[2]) $")
       *EXP("(parm[0]),filters, cc=cc)")
      sed_cc   = dustem_cc(wfine, MODBB(wfine,EXP(parm[1]),parm[2])*EXP(parm[0]),filters, cc=cc)
      print, cc

      (";b.c. Apply color correction factors to the data, then re-run the fitting.")
      ("; The FOR loop here is offset by 4. This is because the color correction is only applied $")

      FOR h = 0, 4 DO BEGIN
      Inu_SED[x,y,h+4] = Inu_SED[x,y,h+4] / cc[h]
Inu_SED("[x,y,h+6] = Inu_SED[x,y,h+6] / cc[h]")
      ENDFOR


